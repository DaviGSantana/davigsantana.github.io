---
title: "Practical Malware Analysis"
date: 2025-11-18 17:00:00 -0300
layout: post
categories: [Labs]
tags: [reverse, malware-analysis]
image: "/assets/img/Post_3/Practical-Malware-Analysis.jpg"
---

In this post, I continue my studies of the book "Practical Malware Analysis" and begin working on Lab 5. The goal is to apply practical static and dynamic analysis techniques to understand the behavior of real samples, reinforcing fundamental concepts used in malware analysis environments. This content is part of my study routine and documentation of the learning steps.

---

## LAB 5-1
```
Lab05-01.dll
```

### Question 1
```
What is the address of DllMain?
```
When loading the DLL in IDA, we will navigate to the DllMain function, and then it is possible to locate its address.

![alt text](/assets/img/Post_3/DllMain.png)

```Answer 
1000D02E
```
---

### Question 2
```
Use the import window to navigate to gethostbyname. Where is the import located?
```
Searching for the imports, find gethostbyname and then locate the address.

![alt text](/assets/img/Post_3/gethostbyname.png)

Imports

![alt text](/assets/img/Post_3/gethostbyname-imports.png)

```Answer 
100163CC
```
---

### Question 3
```
How many functions call gethostmyname?
```
Using the jump list cross-references to, we can view the subroutines/functions.

![alt text](/assets/img/Post_3/xrefs.png)

---

### Question 4
```
Focusing on the call to gethostbyname at 0x10001757. Can you figure out which DNS request will be made?
```

After navigating to the provided address, looking above before the function call, it is possible to see that an address offset is being moved to EAX before 0Dh is added.

![alt text](/assets/img/Post_3/u7WKkGF.png)

E possivel identificar que EAX agora aponta para 0x10019194, dentro dos dados contem: [This is RDO]pics.practicalmalwareanalysis.com

![alt text](/assets/img/Post_3/Qpjnb5F.png)

```Answer
pics.practicalmalwareanalysis.com
```
---

### Question 5
```
How many local variables did IDA recognize for the subroutine at 0x10001656?
```

Navigating to the address 0x10001656, IDA identified the following variables;

![alt text](/assets/img/Post_3/XBMb9le.png)

---

### Question 6
```
How many parameters did IDA recognize for the subroutine at 0x10001656?
```

Looking at the last image provided above, it is possible to see that IpThreadParameter was identified, indicating that 1 parameter was expected in this subroutine.

---

### Question 7
```
Use the strings window to locate the string \cmd.exe /c in the disassembly. Where is it located?
```

![alt text](/assets/img/Post_3/cmdexe.png)

```Answer
10095B34
```
---

### Question 8
```
What's going on in the area of the code that references \cmd.exe /c?
```

Analyzing the function, it is possible to identify a character array 'HiMasterDDDDDD' that mentions 'Remote Shell Session', which leads one to think that it might possibly be a remote shell session function.

![alt text](/assets/img/Post_3/remoteshell.png)
---

### Question 9
```
In the same area, at 0x100101C8, it looks like dword_1008E5C4 is a global variable that helps decide which path to take. How does the malware set dword_1008E5C4? (Hint: Use dword_1008E5C4â€™s cross-references.)
```
Navigating to the address 0x100101C8, it is possible to identify a comparison instruction, comparing ebx with the value dword_1008E5C4. As a hint for the question, when analyzing the cross-references of dword_1008E5C4, it is possible to see that one of them contains the mov instruction to assign the value.

![alt text](/assets/img/Post_3/yE0Gzhw.png)
It is possible to see that the output of sub_10003695 will be moved to dword_1008E5C4.

![alt text](/assets/img/Post_3/RVc5CPK.png)
Let's analyze what this routine is about. Upon analysis, it is possible to verify that it is comparing the platform ID dw with the value 2; -> this indicates that the operating system is Windows NT or later.

![alt text](/assets/img/Post_3/WspNXJd.png)

So, the malware will possibly follow a different path depending on whether the operating system is Windows NT or later.

---

### Question 10
```
A few hundred lines into the subroutine at 0x1000FF58, a series of comparisons use memcmp to compare strings. What happens if the string comparison to robotwork is successful (when memcmp returns 0) 
```

First, let's navigate to the subroutine at 0x1000FF58 and look for the string comparisons that are being made. The buffer is comparing the string 'robotword' found, analyzing the code, it checks if a buffer contains exactly the string 'robotwork', if it does, it executes the function sub_100052A2 passing the value taken from the stack; if not, it jumps to the next flow, loc_10010468.

![alt text](/assets/img/Post_3/robotwork.png)

In sub_100052A2, we will see that it is opening a registry key at: HKLMSOFTWAREMicrosoftWindowsCurrentVersion. In jz, it checks whether the registry was opened successfully or not. If the registry is opened successfully, it will be = 0 and will proceed to loc_10005209.

![alt text](/assets/img/Post_3/reg.png)

In loc_10005309 it is possible to see that it is querying the worktime registry key. In the previous code where the registry key was opened, it is possible to see that a type of argument called socket is being passed with the value s. Going back to the beginning of the question, we can see that this pushes ebp+s, which indicates that this information is sent back through the passed network socket.

![alt text](/assets/img/Post_3/worktime.png)
---

### Question 11
```
What does the PSLIST export command do?
```

After analysis, it is possible to identify that we will have two different paths that will be followed according to the result of sub_100036C3. So let's dive deeper.

![alt text](/assets/img/Post_3/pslist.png)

In subroutine 100036C3, it uses the Windows APIs: GetVersionExA and OSVERSIONINFOA, clearly used to detect the Windows version and return 1 or 0 depending on whether the system meets a specific condition.

![alt text](/assets/img/Post_3/a694BGq.png)






